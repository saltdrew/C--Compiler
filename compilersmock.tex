\documentclass[12pt]{article}
\usepackage[utf8]{inputenc}
\usepackage[numbers]{natbib}
\usepackage{url}
\usepackage{xcolor}
\usepackage{hyperref}
\hypersetup{
    colorlinks = true,
    citecolor = magenta
}

\title{Compilers Mock Exam \\ CAnDL: A Domain Specific Language
for Compiler Analysis}

\begin{document}

\maketitle

\section{Summary of the Problem and Contributions}

The problem addressed by Ginsbach et al. is the difficulty of coding program analysis and its time consuming nature\cite{Ginsbach2018}. They mention that it can take `tens of thousands of lines' to detect where to apply peephole transformations, despite the transformations themselves being fairly simple. They present a solution in the form of a programming language specific to the domain of compiler analysis called the Compiler Analysis Description Language (CAnDL). The language is built around programmer productivity, and focuses on simplifying the process of optimising compiler code. CAnDL code is translated to C++ for use using their compiler. Their results for simple peephole optimisations show that more optimisation opportunities can be found using far fewer lines of code. Similar results are shown for other kinds of optimisations, which highlight the difference in the number of lines of code required, compared to other languages. The contribution to this field is clear, CAnDL is very successful in its role as a programmer-oriented compiler analysis language, and has the potential to make compiler optimisation a far more efficient process. 

\section{Work Presented}

CAnDL is a domain specific language, that works with the LLVM framework. It is first compiled into C++ code that implements the required LLVM analysis functionality. The language is comprised of a set of bindings of constraint formulas to identifiers. There are atomic constraints such as ``data\_type variable = int`` or range constraints e.g `formula foreach ⟨s⟩ = index .. index'. Additionally an important concept in CAnDL is modularity, which is implemented in the form of the include construct. Since this language must be compiled itself, there is an additional layer of overhead that must be considered when comparing to alternatives. 

To evaluate CAnDL, Ginsbach et al. conducted three tests on real world applications. It is used to implement simple peephole implementations, 	graphics shader optimisation and the detection of Static Control flow parts (SCoPs). In the first and third case, it is compared to LLVM's implementation in terms of performance and the number of lines used. In the second case, there was no such implementation to compare, but the performance of the analysed code itself is evaluated. 

These tests lead the developers to draw the conclusion that CAnDL has a small negative impact on compilation time (due to additional overheads), but they vastly reduce the number of lines needed to perform such analyses. This suggests that for the compiler programmer, CAnDL is an extremely useful tool. 

\section{Results}

For the first use case of CAnDL, three metrics were compared, and it was found that `with only 12 lines of CAnDL code, [they]
were able to capture more factorization opportunities than
LLVM did using two hundred lines of code'. However, this did require a greater total compilation time, with a 5\% increase. Though this increase may be small, it should be considered that when this concept is scaled, it could have a significant performance impact. 

In the second use case, no comparison was made to an alternative implementation, but it is worth noting that it the optimisations made a `moderate 1-4\%' increase in graphics shading performance with only 10 lines of code. This example especially demonstrates the effectiveness for the programmer, where 10 lines of code seems almost trivial. 

Perhaps the most promising is the fact that for detecting Static Control Flow parts (SCoPs), which are important for implementing parallelism, CAnDL required vastly fewer lines of code (45 vs 1903) to detect the same optimisations as LLVM's polyhedral implementation. However, only two metrics were compared here - the number of optimisations and the number of lines of code. This means we cannot know the performance impact that CAnDL has for these more complex optimisations. 

\section{Critical Evaluation of Contributon}

Ginsbach et al. provide a valuable contribution to the field of compiler analysis with their domain specific language. This work is novel, with some existing related work, but none that tackle the same issue as CAnDL. For instance, many domain specific languages, such as Rhodium \cite{Lerner2005}, used for writing compiler optimisations do not focus on programmer productivity, but rather verifying the correctness of the optimisations. Additionally, they often deal only with simple peephole optimisations and not more complex ones. This shows that CAnDL is indeed a necessary and novel solution, as it directly addresses the programmer efficiency in writing compiler analyses, rather than just the effect of the analysis and optimisation. 

However there do exist some problems with the methodology that Ginsbach et al. present. Namely the actual performance is only evaluated in one use case, and the comparison in program length is made in only two cases. Realistically in order to determine the effectiveness of this language, a greater number of tests should be performed. Additionally, the authors write their own programs in CAnDL and compare this with only LLVM's implementations of the same optimisations. Though they do find either the same number or more optimisation opportunities in the cases they do test, but more testing is needed to make sure that the analysis program written in CAnDL at least covers all the same optimisations as the LLVM's C++ counterpart. Comparisons should also be made between CAnDL and other suitable alternatives such as those cited in the related works. Despite the programmer being the focus with CAnDL, other metrics such as performance should be evaluated as to ensure they are not compromised. This means measuring the total compile time and comparing with a variety of different implementations, on many kinds of programs, using many types of optimisations. 

Furthermore, the main metric used to indicate the success of the language, is the number of lines required in the program. However this number alone does not necessarily speak to the efficiency of the programming. Although a difference of 45 and 1903 is a clear improvement, the readability and usability of the language is equally important. A dense representation is not necessarily a useful one. To add more evidence to the programming efficiency of this language, a user driven evaluation could be performed. This certainly does not call for many participants, as these would need to be experienced compiler writers, but any additional evidence would be welcomed. 

In conclusion, CAnDL serves its role successfully as a compiler analysis language with the purpose of increasing program clarity and reducing size. It accomplishes its goal to be far more efficient for the programmer. However, it requires more testing to be certain of its effectiveness in performing optimisations, especially in the metric of compile time, where there is a lack of presented evidence. 

\bibliography{comp}
\bibliographystyle{IEEEtranN}

\end{document}


